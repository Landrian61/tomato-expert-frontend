/// <reference lib="webworker" />

import { clientsClaim } from 'workbox-core';
import { ExpirationPlugin } from 'workbox-expiration';
import { precacheAndRoute, createHandlerBoundToURL } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { StaleWhileRevalidate, CacheFirst, NetworkFirst } from 'workbox-strategies';

declare const self: ServiceWorkerGlobalScope;

// Catch and log any errors that occur during service worker operation
self.addEventListener('error', (event) => {
  console.error('Service Worker error:', event.error);
});

// Claim clients so that the service worker is activated immediately
clientsClaim();

// Precache all of the assets generated by your build process.
// Their URLs are injected into the manifest variable below.
// This variable must be present somewhere in your service worker file,
// even if you decide not to use precaching.
precacheAndRoute(self.__WB_MANIFEST);

// Determine if we're in development mode
// This fixes the 'process is not defined' error by not relying on process.env
const isDevelopment = () => {
  try {
    return self.location.hostname === 'localhost' || 
           self.location.hostname.includes('127.0.0.1');
  } catch (e) {
    return false; // Default to production behavior if detection fails
  }
};

// Set debug flag based on environment
const enableDebugLogging = isDevelopment();

// Log debug information if enabled
const debugLog = (...args: any[]) => {
  if (enableDebugLogging) {
    console.log('[Service Worker Debug]', ...args);
  }
};

debugLog('Service worker activated with debug logging enabled');

// Define routes that should be cached using different strategies
// Cache page navigations (HTML) with a Network First strategy
registerRoute(
  // Check to see if the request is a navigation to a new page
  ({ request }) => request.mode === 'navigate',
  new NetworkFirst({
    // Use a custom cache name
    cacheName: 'pages-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 50,
        // Cache for a maximum of 24 hours
        maxAgeSeconds: 24 * 60 * 60
      })
    ]
  })
);

// Cache image files with a Cache First strategy
registerRoute(
  // Check to see if the request's destination is style for an image
  ({ request }) => request.destination === 'image',
  new CacheFirst({
    // Use a custom cache name
    cacheName: 'image-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 100,
        // Cache for a maximum of 30 days
        maxAgeSeconds: 30 * 24 * 60 * 60
      })
    ]
  })
);

// Cache CSS, JS, and Web Worker requests with a Stale While Revalidate strategy
registerRoute(
  ({ request }) =>
    request.destination === 'style' ||
    request.destination === 'script' ||
    request.destination === 'worker',
  new StaleWhileRevalidate({
    cacheName: 'assets-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 60,
        maxAgeSeconds: 24 * 60 * 60 // 24 hours
      })
    ]
  })
);

// This allows the web app to trigger skipWaiting via
// registration.waiting.postMessage({type: 'SKIP_WAITING'})
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
    debugLog('Skip waiting message received - activating immediately');
  }
});

// Background sync for failed requests
self.addEventListener('sync', (event) => {
  if (event.tag === 'syncDiagnosisData') {
    debugLog('Background sync for diagnosis data triggered');
    // Handle syncing data
  }
});
